% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/routing.R
\name{get_route_lengths}
\alias{get_route_lengths}
\title{Routing between two dataframes}
\usage{
get_route_lengths(
  source,
  destination,
  profile,
  units = "m",
  geometry = FALSE,
  ...
)
}
\arguments{
\item{source}{Source dataset that represents point coordinates that are to
be routed from. The source dataset should be passed as a double nested
dataframe with each row representing a x/y or lon/lat coordinate
pair or as an \code{sf} or \code{sfc} object containing point geometries.}

\item{destination}{Destination dataset that represents point coordinates
that are to be routed to. The destination dataset follows the same format
requirements as the source dataset.}

\item{profile}{Character scalar. Means of transport as supported by
OpenRouteService. For a list of active profiles, call
\code{\link{get_profiles}}. For details on all profiles, refer to the
\href{https://giscience.github.io/openrouteservice/documentation/Tag-Filtering.html}{documentation}.}

\item{units}{Distance unit for distance calculations ('m', 'km' or 'mi')}

\item{geometry}{If \code{TRUE}, returns a \code{sf} object containing route
geometries. If \code{FALSE}, returns route distance measures.}

\item{...}{Additional arguments passed to the ORS API. This includes all
options that modify the routing results. For details on each argument,
refer to the
\href{https://openrouteservice.org/dev/#/api-docs/v2/directions/{profile}/post}{API playground}
and
\href{https://github.com/GIScience/openrouteservice-docs#routing-options}{documentation}
\itemize{
\item{\strong{geometry_simplify}}: {Logical length-1 vector specifying whether
geometry should be simplified.}
\item{\strong{continue_straight}}: {Logical length-1 vector. If \code{FALSE}, avoids
u-turns and forces the route to keep going
straight}
\item{\strong{avoid_borders}}: {Length-1 character vector specifying whether to avoid
all borders, only controlled ones or none.}
\item{\strong{avoid_countries}}: {Numeric vector listing countries to avoid. Each
country is assigned a numeric value. Refer to the
ORS documentation.}
\item{\strong{avoid_features}}: {Traffic features to avoid (e.g. highways or tunnels)}
\item{\strong{avoid_polygons}}: {\code{sf} or \code{sfc} object describing areas to
avoid.}
\item{\strong{preference}}: {Length-1 character value describing the routing
preference. Either "recommended", "fastest" or
"shortest"}
\item{\strong{radiuses}}: {Maximum distance (in m) that road segments can be snapped
to. \code{-1} represents an unlimited radius. This option
can also be adjusted in the ORS service configurations.}
\item{\strong{maximum_speed}}: {Numeric length-1 vector specifying the maximum speed.}
}}
}
\value{
Dataframe with distances and travel durations between source and
destination. If \code{geometry = TRUE}, returns an \code{sf} object
containing the route geometries.
}
\description{
Calculates the routing distance between two datasets.
}
\section{Error handling}{

Since \code{get_route_lengths} is supposed to conduct a lot of calculations
in one go, errors might occur even in well-conceived service setups. In
order to make debugging less painful, errors do not tear down the whole
process. They are saved to an environment and issue a warning containing the
indices of the routes in question. After the process has finished, they can
be accessed by calling \code{\link{last_ors_errors}}. Note, that only the
last function call can be accessed as the error cache is cleared with each
function call.
}

\examples{
set.seed(111)
source <- ors_sample(10)
source_sf <- ors_sample[1:5, ]
source_df <- as.data.frame(sf::st_coordinates(ors_sample[6:10, ]))

set.seed(222)
dest <- ors_sample(10)
dest_sf <- ors_sample[1:5, ]
dest_df <- as.data.frame(sf::st_coordinates(ors_sample[6:10, ]))

profile <- get_profiles()[1]

# Running with sf objects
route_lengths_sf <- get_route_lengths(source_sf, dest_sf, profile)
route_lengths_sf

# Running with coordinate pairs
route_lengths_df <- get_route_lengths(source_df, dest_df, profile)
route_lengths_df

# Returns route geometries
route_lengths_geom <- get_route_lengths(source_df, dest_df, profile, geometry = TRUE)

# Returns routes in kilometers
route_lengths_km <- get_route_lengths(source_df, dest_df, profile, units = "km")

# Running with additional arguments
route_lengths_opts <- get_route_lengths(source_dd, dest_df, profile, continue_straight = TRUE, preference = "fastest")
}
