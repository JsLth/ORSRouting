% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/route-distances.R
\name{ors_distances}
\alias{ors_distances}
\alias{ors_shortest_distances}
\title{Routing distance computations}
\usage{
ors_distances(
  source,
  destination,
  profile = get_profiles(),
  units = c("m", "km", "mi"),
  geometry = FALSE,
  instance = NULL,
  ...
)

ors_shortest_distances(
  source,
  destination,
  group = NULL,
  profile = get_profiles(),
  units = c("m", "km", "mi"),
  geometry = FALSE,
  instance = NULL,
  ...,
  proximity_type = c("duration", "distance")
)
}
\arguments{
\item{source}{\code{[sf]}

Source dataset containing point geometries that shall be routed from.}

\item{destination}{\code{[sf]}

Destination dataset containing point geometries that shall be routed from.
The destination dataset follows the same format requirements as the source
dataset. For \code{ors_shortest_distances}, the destination argument can also
be a dataframe containing a grouping column specified by the \code{group}
argument that indicates which destinations refer to which row in the source
dataset (as returned by \code{\link{get_closest_pois}}). This is
recommended for large datasets because passing a plain sf dataframe routes
from each source point to each point in the entire destination dataset.}

\item{profile}{\code{[character]}

Character vector. Means of transport as supported by OpenRouteService. For a
list of active profiles, call \code{\link{get_profiles}}. For details on all
profiles, refer to the
\href{https://giscience.github.io/openrouteservice/documentation/Tag-Filtering.html}{documentation}.}

\item{units}{\code{[character]}

Distance unit for distance calculations (\code{"m"}, \code{"km"} or
\code{"mi"})}

\item{geometry}{\code{[logical]}

If \code{TRUE}, returns a \code{sf} object containing route geometries. If
\code{FALSE}, returns route distance measures. Defaults to \code{FALSE}, to
increase performance.}

\item{instance}{\code{[ors_instance]}

Object of an OpenRouteService instance that should be used for route
computations. It is recommended to use \code{\link{ors_instance}}
to set an instance globally. This argument should only be used if activating
an instance globally is not feasible.}

\item{...}{Additional arguments passed to the ORS API. This includes all
options that modify the routing results. For details on each argument,
refer to the
\href{https://openrouteservice.org/dev/#/api-docs/v2/directions/{profile}/post}{API playground}
and
\href{https://giscience.github.io/openrouteservice/documentation/routing-options/Routing-Options.html}{documentation}
\describe{
\item{\strong{geometry_simplify}}{Logical length-1 vector specifying
whether geometry should be simplified.}
\item{\strong{continue_straight}}{Logical length-1 vector. If \code{FALSE},
avoids u-turns and forces the route to
keep going straight.}
\item{\strong{avoid_borders}}{Length-1 character vector specifying whether
to avoid, all borders, only controlled ones
or none. Only available for \code{driving-*}.}
\item{\strong{avoid_countries}}{Numeric vector listing countries to avoid.
Each country is assigned a numeric value.
Refer to the ORS documentation. Only
available for \code{driving-*}.}
\item{\strong{avoid_features}}{Character vector containing traffic features
to avoid (e.g. highways or tunnels).}
\item{\strong{avoid_polygons}}{\code{sf} or \code{sfc} object describing
areas to avoid.}
\item{\strong{profile_params}}{Nested list containing restrictions and
weightings for \code{driving-hgv},
\code{cycling-*}, \code{walking},
\code{hiking} and \code{wheelchair}.}
\item{\strong{vehicle_type}}{Length-1 character vector specifying the type
of heavy goods vehicle. Needed to set
restrictions for \code{driving-hgv}.}
\item{\strong{preference}}{Length-1 character vector describing the routing
preference. Either "recommended", "fastest" or
"shortest".}
\item{\strong{radiuses}}{Maximum distance (in m) that road segments can be
snapped to. \code{radiuses = -1} represents an
unlimited radius. This option can also be adjusted
in the ORS service configurations.}
\item{\strong{maximum_speed}}{Numeric length-1 vector specifying the
maximum speed.}
}}

\item{group}{\code{[character/numeric]}

Column name or index providing a grouping column that indicates which row
in the destination dataset corresponds to which row in the source dataset
(as in the output of \code{\link{get_closest_pois}}). Providing
a grouping column can considerably reduce the processing load for larger
datasets.}

\item{proximity_type}{\code{[character]}

Type of proximity that the calculations should be
based on. If \code{distance}, the shortest physical distance will be calculated
and if \code{duration}, the shortest temporal distance will be calculated.}
}
\value{
\code{ors_distances} returns a dataframe with distances and
travel durations between source and destination.
\code{ors_shortest_distances} returns a dataframe containing distances,
travel durations and the index number of the point of interest with the
shortest routing distance to the respective place of the source dataset.
Depending on the \code{geometry} argument, these outputs can either be
simple dataframes or objects of class \code{sf} containing the linestring
geometries of the respective routes.

\code{ors_shortest_distances} returns a dataframe containing
distances, travel durations and the index number of the point of interest
with the shortest routing distance to the respective place of the source
dataset.
}
\description{
\code{ors_distances} calculates the routing distance between two
datasets using the Directions service from ORS. \code{ors_shortest_distances}
is a wrapper around \code{ors_distances} that matches each point of the
source dataset to a dataset of points of interest from the destination dataset
and then extracts the route with the shortest distance.
}
\details{
For \code{ors_distances}, the profile argument supports only length-1
vectors while \code{ors_shortest_distances} supports multiple profiles.
\code{ors_shortest_distances} finds the shortest route for each source
point and each profile, respectively.
}
\section{Error handling}{

Since \code{ors_distances} is supposed to conduct a lot of calculations
in one go, errors might occur even in well-conceived service setups. In
order to make debugging less painful, errors do not tear down the whole
process. They are saved to an environment and issue a warning containing the
indices of the routes in question. After the process has finished, they can
be accessed by calling \code{\link{last_ors_conditions}}. Specific routes
can be examined by inspecting its route attributes using
\code{\link{ors_inspect}}.
}

\examples{
\dontrun{
set.seed(111)
source_sf <- ors_sample(10, as_sf = TRUE)
source_df <- ors_sample(10)

set.seed(222)
dest_sf <- ors_sample(10, as_sf = TRUE)
dest_df <- ors_sample(10)

car = "driving-car"
bike = "cycling-regular"

# Running with sf objects
route_lengths_sf <- ors_distances(source_sf, dest_sf, profile = car)
route_lengths_sf

# Running with coordinate pairs
route_lengths_df <- ors_distances(source_df, dest_df, profile = bike)
route_lengths_df

# Returns route geometries
route_lengths_geom <- ors_distances(
  source_df,
  dest_df,
  profile = car,
  geometry = TRUE
)

# Returns routes in kilometers
route_lengths_km <- ors_distances(
  source_df,
  dest_df,
  profile = bike,
  units = "km"
)

# Running with additional arguments
route_lengths_opts <- ors_distances(
  source_df,
  dest_df,
  profile = car,
  continue_straight = TRUE,
  preference = "fastest"
)
                                    
# Finding shortest routes from each point in sample_a to sample_b
shortest_routes <- ors_shortest_distances(source_df, dest_df, units = "km")
shortest_routes

# Finding the shortest routes to the nearest hospitals
pois <- get_osm_pois(sf::st_bbox(source_sf), amenity = "hospital")

nearest_hospitals <- ors_shortest_distances(
  source,
  pois,
  geometry = TRUE
)
nearest_hospitals
}
\dontrun{
}
}
