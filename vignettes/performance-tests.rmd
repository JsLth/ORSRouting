---
title: "Testing routing performance"
author: Jonas Lieth
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Testing routing performance}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

The purpose of this vignette is to test the procedural performance of the matrix and directions services regarding processing time and system usage. This information can be used to gain insights into the speed performance of OpenRouteService and the degree to which OpenRouteService utilizes the local system. It's also good to know how the matrix and directions service compare to each other to decide if it makes sense to apply one or the other for certain tasks.
The code chucks use the package `microbenchmark` to gather performance data, `docker stats` using `shell()` and `callr` to gather system usage data and `ggplot2` to visualize the results.

```{r setup, results = FALSE}
library(ORSRouting)
library(ggplot2)
```

The performance tests were conducted from the following system:

```{r system-info, echo = FALSE}
cpu_name <- benchmarkme::get_cpu()$model_name
cpu_cores <- benchmarkme::get_cpu()$no_of_cores
tram <- round(memuse::Sys.meminfo()$totalram@size, 1)
fram <- round(memuse::Sys.meminfo()$freeram@size, 1)
os <- Sys.info()["sysname"]

data.frame(Specification = c(cpu_name, cpu_cores, tram, fram, os),
           row.names = c("CPU model", "Cores", "Total RAM", "Free RAM", "OS"))
```

System usage data are collected by running `docker stats` from `shell()` inside a separate R session. The background session is managed by `callr` and captures CPU and memory percentages every three seconds. The data is then saved to a temporary file which can later be read to a dataframe.

```{r docker-logging}
log_system_usage <- function(output_file) {
  log <- function(output_file) {
    while(TRUE) {
      shell(paste("docker stats --no-stream --format",
                  "\"{{.CPUPerc}},{{.MemPerc}}\"",
                  "ors-app",
                  "| sed s/%//g >>",
                  output_file),
            wait = TRUE)
      Sys.sleep(3)
    }
  }
  if (file.exists(output_file)) unlink(output_file)
  cat("CPU,Memory\n", file = output_file)
  callr::r_bg(log, args = list(output_file))
}

log_file <- file.path(normalizePath(tempdir(), winslash = "/"), "docker_stats.txt")
logger <- log_system_usage(log_file)
```

Prepare sample datasets:

```{r generate-data}
set.seed(111)
sample_a <- ors_sample(100)

set.seed(222)
sample_b <- ors_sample(100)
```

`get_route_lengths` is tested iteratively with different input sample sizes. Every function call is measured 30 times with 21 calls in total ranging from a sample size of 1 to a sample size of 100. Finally, the logger is stopped and the time different calculated.

```{r rowwise-benchmark, results = FALSE}
iterator <- seq(0, 100, by = 5)
iterator[1] <- 1

rowwise_directions <- map(
        iterator,
        ~ microbenchmark::microbenchmark(
                get_route_lengths(sample_a[seq_len(..1), ],
                                  sample_b[seq_len(..1), ],
                                  "driving-car",
                                  how = "directions"),
                times = 30
        )
)

rowwise_matrix <- map(
        iterator,
        ~ microbenchmark::microbenchmark(
                get_route_lengths(sample_a[seq_len(..1), ],
                                  sample_b[seq_len(..1), ],
                                  "driving-car",
                                  how = "directions"),
                times = 30
        )
)

logger$kill()
end <- Sys.time()
start <- logger$get_start_time()
total_time <- as.numeric(difftime(end, start, units = "secs"))
```

```{r plot-rowwise-time}
plot_processing_time <- function(directions, matrix, type) {
  directions_mean <- map(directions, ~mean(..1$time) / 1000000) %>% unlist()
  directions_min <- map(directions, ~min(..1$time) / 1000000) %>% unlist()
  directions_max <- map(directions, ~max(..1$time) / 1000000) %>% unlist()
  matrix_mean <- map(matrix, ~mean(..1$time) / 1000000) %>% unlist()
  matrix_min <- map(matrix, ~min(..1$time) / 1000000) %>% unlist()
  matrix_max <- map(matrix, ~max(..1$time) / 1000000) %>% unlist()

  directions_df <- data.frame(elements = iterator,
                              mean = directions_mean,
                              max = directions_max,
                              min = directions_min)

  matrix_df<- data.frame(elements = iterator,
                         mean = matrix_mean,
                         max = matrix_max,
                         min = matrix_min)

  directions_df$type <- "Directions"
  matrix_df$type <- "Matrix"

  directions_matrix <- rbind(directions_df, matrix_df)

  time_plot <- ggplot(data = directions_matrix, aes(fill = type, linetype = type)) +
    geom_line(aes(x = elements, y = mean), size = 1) +
    geom_ribbon(aes(x = elements, y = mean, ymin = min, ymax = max), alpha = 0.3) +
    labs(x = "Number of routes",
         y = "Mean processing time (in s)",
         title = sprintf("Processing time - Matrix vs. Directions (%s)", type)) +
    scale_fill_discrete(labels = c("Matrix", "Directions"), name = "Method") +
    scale_linetype_discrete(labels = c("Matrix", "Directions"), name = "Method") +
    scale_x_continuous(expand = c(0, 0), limits = c(0, NA)) +
    scale_y_continuous(expand = c(0, 0), limits = c(0, NA))

  plot(time_plot)
}

plot_processing_time(rowwise_directions, rowwise_matrix, "rowwise")
```

```{r plot-rowwise-usage}
plot_system_usage <- function(directions, matrix, log_file, type, log_time) {
  parsed_log <- read.csv(log_file, header = TRUE)
  system_usage <- data.frame(CPU = parsed_log$CPU,
                             Memory = parsed_log$Memory)

  time_vec <- round(seq(2, log_time, length.out = nrow(system_usage)), 0)
  total_time_matrix <- sum(matrix$time / 1000000 * 30)
  total_time_directions <- sum(directions$time / 1000000 * 30)

  xmin_dir <- time_vec[match(max(system_usage$CPU), system_usage$CPU)]
  xmax_dir <- xmin_dir + total_time_directions
  xmax_mat <- xmax_dir + total_time_matrix
  ymax <- max(system_usage$CPU)

  system_usage_comb <- stack(system_usage)
  system_usage_comb$time <- rep(time_vec, 2)

  usage_plot <- ggplot(data = system_usage_comb, aes(x = time, y = values, linetype = ind)) +
    geom_line(size = 1) +
    labs(x = "Time (in s)",
         y = "Component utilization (in %)",
         title = sprintf("System usage - Matrix vs. Directions (%s)", type),
         linetype = "Component type") +
    scale_x_continuous(expand = c(0, 0), limits = c(0, NA)) +
    scale_y_continuous(expand = c(0, 0), limits = c(0, NA))

  plot(usage_plot)
}

plot_system_usage(rowwise_directions, rowwise_matrix, log_file, "rowwise", total_time)
```

```{r plot-otm}
logger <- log_system_usage(log_file)

otm_directions <- map(
        iterator,
        ~ microbenchmark::microbenchmark(
                get_route_lengths(sample_a[1, ],
                                  sample_b[seq_len(..1), ],
                                  "driving-car",
                                  how = "directions"),
                times = 30
        )
)

otm_matrix <- map(
        iterator,
        ~ microbenchmark::microbenchmark(
                get_route_lengths(sample_a[1, ],
                                  sample_b[seq_len(..1), ],
                                  "driving-car",
                                  how = "directions"),
                times = 30
        )
)

logger$kill()
end <- Sys.time()
start <- logger$get_start_time()
total_time <- as.numeric(difftime(end, start, units = "secs"))

plot_processing_time(otm_directions, otm_matrix, "one to many")
plot_system_usage(otm_directions, otm_matrix, log_file, "one to many", total_time)
```

Generally, there seems to be little variation in the processing time of both methods. However, these results only show processing times for